#ifndef RELBOOST_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_
#define RELBOOST_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_

// ----------------------------------------------------------------------------

namespace relboost
{
namespace ensemble
{
// ------------------------------------------------------------------------

class DecisionTreeEnsemble
{
   public:
    DecisionTreeEnsemble(
        const std::shared_ptr<const std::vector<std::string>>& _encoding,
        const std::shared_ptr<const Hyperparameters>& _hyperparameters,
        const std::shared_ptr<const std::vector<std::string>>& _peripheral,
        const std::shared_ptr<const Placeholder>& _placeholder )
        : impl_( DecisionTreeEnsembleImpl(
              _encoding, _hyperparameters, _peripheral, _placeholder ) ),
          targets_( std::make_shared<std::vector<RELBOOST_FLOAT>>( 0 ) )
    {
        loss_function_ = lossfunctions::LossFunctionParser::parse(
            _hyperparameters->objective_, impl().hyperparameters_, targets_ );
    }

    DecisionTreeEnsemble( const DecisionTreeEnsemble& _other )
        : impl_( _other.impl() ),
          targets_( std::make_shared<std::vector<RELBOOST_FLOAT>>( 0 ) )
    {
        loss_function_ = lossfunctions::LossFunctionParser::parse(
            _other.loss_function().type(), impl().hyperparameters_, targets_ );
    }

    DecisionTreeEnsemble( DecisionTreeEnsemble&& _other ) noexcept
        : impl_( std::move( _other.impl() ) ), targets_( _other.targets_ )
    {
        loss_function_ = lossfunctions::LossFunctionParser::parse(
            _other.loss_function().type(), impl().hyperparameters_, targets_ );
    }

    ~DecisionTreeEnsemble() = default;

    // -----------------------------------------------------------------

   public:
    /// Copy constructor
    DecisionTreeEnsemble& operator=( const DecisionTreeEnsemble& _other );

    /// Copy assignment constructor
    DecisionTreeEnsemble& operator=( DecisionTreeEnsemble&& _other ) noexcept;

    /// Fits the DecisionTreeEnsemble.
    void fit(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral );

    /// Generates predictions.
    std::vector<RELBOOST_FLOAT> predict(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral ) const;

    /// Saves the DecisionTreeEnsemble into a JSON file.
    void save( const std::string& _fname ) const;

    /// Returns the features underlying the model (the predictions of the
    /// individual trees as opposed to the entire prediction)
    std::vector<RELBOOST_FLOAT> transform(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral ) const;

    /// Expresses DecisionTreeEnsemble as Poco::JSON::Object.
    Poco::JSON::Object to_json() const;

    /// Expresses DecisionTreeEnsemble as SQL code.
    std::string to_sql() const;

    // -----------------------------------------------------------------

   private:
    // Calculates the loss reduction of the predictions generated by a
    // candidate.
    RELBOOST_FLOAT calc_loss_reduction(
        const decisiontrees::DecisionTree& _decision_tree,
        const std::vector<RELBOOST_FLOAT>& _yhat_old,
        const std::vector<RELBOOST_FLOAT>& _predictions ) const;

    /// Fits a new slate of candidate trees.
    decisiontrees::DecisionTree fit_new_tree(
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function,
        const TableHolder& _table_holder,
        std::vector<RELBOOST_FLOAT>* _yhat_old );

    /// Generates a new slate of predictions.
    std::vector<RELBOOST_FLOAT> generate_predictions(
        const decisiontrees::DecisionTree& _decision_tree,
        const TableHolder& _table_holder ) const;

    /// Returns the number of matches for each element of the population table.
    std::shared_ptr<std::vector<RELBOOST_FLOAT>> make_counts(
        const size_t _nrows,
        const std::vector<const containers::Match*>& _matches_ptr );

    // -----------------------------------------------------------------

   private:
    /// Trivial (private) accessor
    const Hyperparameters& hyperparameters() const
    {
        assert( impl().hyperparameters_ );
        return *impl().hyperparameters_;
    }

    /// Trivial (private) accessor
    DecisionTreeEnsembleImpl& impl() { return impl_; }

    /// Trivial (private) accessor
    const DecisionTreeEnsembleImpl& impl() const { return impl_; }

    /// Trivial (private) accessor
    RELBOOST_FLOAT& initial_prediction() { return impl().initial_prediction_; }

    /// Trivial (private) accessor
    const RELBOOST_FLOAT initial_prediction() const
    {
        return impl().initial_prediction_;
    }

    /// Trivial (private) accessor
    lossfunctions::LossFunction& loss_function()
    {
        assert( loss_function_ );
        return *loss_function_;
    }

    /// Trivial (private) accessor
    const lossfunctions::LossFunction& loss_function() const
    {
        assert( loss_function_ );
        return *loss_function_;
    }

    /// Trivial (private) accessor
    const std::vector<std::string>& peripheral_names() const
    {
        assert( impl().peripheral_names_ );
        return *impl().peripheral_names_;
    }

    /// Trivial (private) accessor
    const Placeholder& placeholder() const
    {
        assert( impl().placeholder_ );
        return *impl().placeholder_;
    }

    /// Trivial (private) accessor
    utils::Sampler& sampler() { return impl().sampler_; }

    /// Trivial (private) accessor
    std::vector<RELBOOST_FLOAT>& targets()
    {
        assert( targets_ );
        return *targets_;
    }

    /// Trivial (private) accessor
    const std::vector<RELBOOST_FLOAT>& targets() const
    {
        assert( targets_ );
        return *targets_;
    }

    /// Trivial (private) accessor
    std::vector<decisiontrees::DecisionTree>& trees() { return impl().trees_; }

    /// Trivial (private) accessor
    const std::vector<decisiontrees::DecisionTree>& trees() const
    {
        return impl().trees_;
    }

    /// Updates the prediction.
    void update_predictions(
        const RELBOOST_FLOAT _update_rate,
        const std::vector<RELBOOST_FLOAT>& _predictions,
        std::vector<RELBOOST_FLOAT>* _yhat_old ) const
    {
        assert( _predictions.size() == _yhat_old->size() );
        std::transform(
            _yhat_old->begin(),
            _yhat_old->end(),
            _predictions.begin(),
            _yhat_old->begin(),
            [this, _update_rate](
                const RELBOOST_FLOAT yhat, const RELBOOST_FLOAT pred ) {
                return yhat + pred * hyperparameters().eta_ * _update_rate;
            } );
    }

    // -----------------------------------------------------------------

   private:
    /// The implementation (variables we can copy without problems).
    DecisionTreeEnsembleImpl impl_;

    /// The loss function to be minimized.
    std::shared_ptr<lossfunctions::LossFunction> loss_function_;

    /// Target variables (previous trees already substracted).
    std::shared_ptr<std::vector<RELBOOST_FLOAT>> targets_;

    // -----------------------------------------------------------------
};

// ------------------------------------------------------------------------
}  // namespace ensemble
}  // namespace relboost

// ----------------------------------------------------------------------------

#endif  // RELBOOST_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_