#ifndef DATABASE_POSTGRESITERATOR_HPP_
#define DATABASE_POSTGRESITERATOR_HPP_

namespace database
{
// ----------------------------------------------------------------------------

class PostgresIterator : public Iterator
{
    // -------------------------------

   public:
    PostgresIterator(
        const std::shared_ptr<pqxx::connection>& _connection,
        const std::vector<std::string>& _colnames,
        const std::vector<std::string>& _time_formats,
        const std::string& _tname,
        const std::string& _where );

    ~PostgresIterator();

    // -------------------------------

   public:
    /// Returns a double and increments the iterator.
    Float get_double() final
    {
        check();

        const auto val = ( *rows_iterator_ )[colnum_].as<Float>( NAN );

        increment();

        return val;
    }

    /// Returns an int and increments the iterator.
    Int get_int() final
    {
        check();

        const auto val = ( *rows_iterator_ )[colnum_].as<Int>( -1 );

        increment();

        return val;
    }

    /// Returns a string and increments the iterator.
    std::string get_string() final
    {
        check();

        const std::string val = ( ( *rows_iterator_ )[colnum_].is_null() )
                                    ? "NULL"
                                    : ( *rows_iterator_ )[colnum_].c_str();

        increment();

        return val;
    }

    /// Returns a time stamps and increments the iterator.
    Float get_time_stamp() final
    {
        check();

        const auto val = ( *rows_iterator_ )[colnum_].as<Float>( NAN );

        increment();

        return val;
    }

    /// Whether the end is reached.
    bool end() const final { return ( rows_iterator_ == rows().end() ); }

    // -------------------------------

   private:
    /// Prevents segfaults before getting the next entry.
    void check()
    {
        if ( end() )
            {
                throw std::invalid_argument( "End of query is reached." );
            }

        if ( colnum_ >= rows_iterator_->size() )
            {
                throw std::invalid_argument( "Row number out of bounds." );
            }
    }

    /// Trivial (private) accessor
    pqxx::connection& connection() const
    {
        assert( connection_ );
        return *connection_;
    }

    /// Trivial (private) accessor
    pqxx::result& current_row() const
    {
        assert( rows_ );
        return *rows_;
    }

    /// Increments the iterator.
    void increment()
    {
        if ( ++colnum_ == num_cols_ )
            {
                colnum_ = 0;
                ++rows_iterator_;
            }
    }

    /// Trivial (private) accessor
    pqxx::result& rows() const
    {
        assert( rows_ );
        return *rows_;
    }

    /// Trivial (private) accessor
    pqxx::work& work() const
    {
        assert( work_ );
        return *work_;
    }

    // -------------------------------

   private:
    /// The current column.
    int colnum_;

    /// Shared ptr containing the connection object.
    const std::shared_ptr<pqxx::connection> connection_;

    /// The total number of columns.
    const size_t num_cols_;

    /// Iterator to the current row.
    pqxx::result::const_iterator rows_iterator_;

    /// Pointer to the rows generated by the query.
    std::unique_ptr<pqxx::result> rows_;

    /// Vector containing the time formats.
    const std::vector<std::string> time_formats_;

    /// Pointer to the work generated by the query.
    std::unique_ptr<pqxx::work> work_;

    // -------------------------------
};

// ----------------------------------------------------------------------------

}  // namespace database

#endif  // DATABASE_POSTGRESITERATOR_HPP_
