#ifndef RELMT_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_
#define RELMT_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_

// ----------------------------------------------------------------------------

namespace relmt
{
namespace ensemble
{
// ------------------------------------------------------------------------

class DecisionTreeEnsemble
{
    // ------------------------------------------------------------------------

   public:
    typedef FitParams FitParamsType;
    typedef TransformParams TransformParamsType;

    typedef relmt::containers::DataFrame DataFrameType;
    typedef relmt::containers::DataFrameView DataFrameViewType;
    typedef relmt::containers::Features FeaturesType;
    typedef relmt::Hyperparameters HypType;
    typedef relmt::containers::Placeholder PlaceholderType;

    typedef DataFrameType::FloatColumnType FloatColumnType;
    typedef DataFrameType::IntColumnType IntColumnType;

    constexpr static bool is_time_series_ = false;
    constexpr static bool premium_only_ = true;
    constexpr static bool supports_multiple_targets_ = false;

    // ------------------------------------------------------------------------

   public:
    DecisionTreeEnsemble(
        const std::shared_ptr<const Hyperparameters>& _hyperparameters,
        const std::shared_ptr<const std::vector<std::string>>& _peripheral,
        const std::shared_ptr<const containers::Placeholder>& _placeholder,
        const std::shared_ptr<const std::vector<containers::Placeholder>>&
            _peripheral_schema = nullptr,
        const std::shared_ptr<const containers::Placeholder>&
            _population_schema = nullptr );

    DecisionTreeEnsemble( const Poco::JSON::Object& _obj );

    DecisionTreeEnsemble( const DecisionTreeEnsemble& _other );

    DecisionTreeEnsemble( DecisionTreeEnsemble&& _other ) noexcept;

    ~DecisionTreeEnsemble() = default;

    // -----------------------------------------------------------------

   public:
    /// Deletes ressources that are no longer needed.
    void clean_up();

    /// Calculates the column importances for this ensemble.
    std::map<helpers::ColumnDescription, Float> column_importances(
        const std::vector<Float>& _importance_factors,
        const bool _is_subfeatures ) const;

    /// Calculates the column importance for a particular tree.
    std::map<helpers::ColumnDescription, Float> column_importance_for_tree(
        const Float _importance_factors,
        const decisiontrees::DecisionTree& _tree ) const;

    /// Fits the DecisionTreeEnsemble.
    void fit( const FitParams& _params );

    /// Fits a new set of candidate features.
    std::vector<
        std::tuple<decisiontrees::DecisionTree, Float, std::vector<Float>>>
    fit_candidate_features(
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function,
        const std::shared_ptr<const TableHolder>& _table_holder,
        const std::vector<containers::Subfeatures>& _subfeatures,
        const std::shared_ptr<const std::vector<Float>>& _sample_weights )
        const;

    /// Fits more features - uses a round-robin approach over all
    /// possible joins and aggregations.
    void fit_new_features(
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function,
        const std::shared_ptr<const TableHolder>& _table_holder,
        const std::vector<containers::Subfeatures>& _subfeatures,
        const size_t _num_features );

    /// Fits the subensembles.
    void fit_subensembles(
        const std::shared_ptr<const TableHolder>& _table_holder,
        const std::shared_ptr<const logging::AbstractLogger> _logger,
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function );

    /// Initializes the fitting process.
    std::pair<
        std::shared_ptr<lossfunctions::LossFunction>,
        std::shared_ptr<const TableHolder>>
    init(
        const containers::DataFrameView& _population,
        const std::vector<containers::DataFrame>& _peripheral,
        const helpers::RowIndexContainer& _row_indices,
        const helpers::WordIndexContainer& _word_indices,
        const std::optional<const helpers::FeatureContainer>&
            _feature_container );

    /// Returns the predictions generated by the subfeatures.
    /// This is in the .cpp to escape the circular dependency
    /// with SubtreeHelper.
    std::vector<containers::Predictions> make_subpredictions(
        const TableHolder& _table_holder,
        const std::shared_ptr<const logging::AbstractLogger> _logger,
        multithreading::Communicator* _comm ) const;

    /// Copy constructor
    DecisionTreeEnsemble& operator=( const DecisionTreeEnsemble& _other );

    /// Copy assignment constructor
    DecisionTreeEnsemble& operator=( DecisionTreeEnsemble&& _other ) noexcept;

    /// Returns the features underlying the model (the predictions of the
    /// individual trees as opposed to the entire prediction)
    containers::Features transform( const TransformParams& _params ) const;

    /// Returns one feature.
    std::shared_ptr<const std::vector<Float>> transform(
        const TableHolder& _table_holder,
        const std::vector<containers::Subfeatures>& _subfeatures,
        size_t _n_feature ) const;

    /// Expresses DecisionTreeEnsemble as Poco::JSON::Object.
    Poco::JSON::Object to_json_obj( const bool _schema_only = false ) const;

    /// Expresses DecisionTreeEnsemble as SQL code.
    std::vector<std::string> to_sql(
        const std::shared_ptr<const std::vector<strings::String>>& _categories,
        const std::string& _feature_prefix = "",
        const size_t _offset = 0,
        const bool _subfeatures = true ) const;

    // -----------------------------------------------------------------

   public:
    /// Trivial accessor
    bool& allow_http() { return impl().allow_http_; }

    /// Trivial accessor
    bool allow_http() const { return impl().allow_http_; }

    /// Trivial (const) accessor
    const Hyperparameters& hyperparameters() const
    {
        throw_unless(
            impl().hyperparameters_, "Model has no hyperparameters." );
        return *impl().hyperparameters_;
    }

    /// Initializes the fitting process with this being a
    /// a subensemble.
    void init_as_subensemble( multithreading::Communicator* _comm )
    {
        set_comm( _comm );
    }

    /// Whether this is a classification problem
    const bool is_classification() const
    {
        return loss_function().type() != "SquareLoss";
    }

    /// Trivial accessor.
    size_t num_features() const { return trees().size(); }

    /// Trivial  accessor.
    const std::vector<std::string>& peripheral() const
    {
        throw_unless(
            impl().peripheral_,
            "Model has no peripheral - did you maybe forget to fit "
            "it?" );
        return *impl().peripheral_;
    }

    /// Trivial (const) accessor
    const std::vector<containers::Placeholder>& peripheral_schema() const
    {
        throw_unless(
            impl().peripheral_schema_,
            "Model has no peripheral schema - did you maybe forget to fit "
            "it?" );
        return *impl().peripheral_schema_;
    }

    /// Trivial accessor.
    const containers::Placeholder& placeholder() const
    {
        throw_unless( impl().placeholder_, "Model has no placeholder." );
        return *impl().placeholder_;
    }

    /// Trivial (const) accessor
    const containers::Placeholder& population_schema() const
    {
        throw_unless(
            impl().population_schema_,
            "Model has no population schema - did you may be forget to fit "
            "it?" );
        return *impl().population_schema_;
    }

    // -----------------------------------------------------------------

   private:
    /// Calculates the initial prediction.
    void calc_initial_prediction();

    /// Calculates the thread nums for fit(...) and transform(...).
    std::pair<Int, std::vector<size_t>> calc_thread_nums(
        const containers::DataFrame& _population ) const;

    // Makes sure that the target values are well-behaved.
    void check_plausibility_of_targets(
        const containers::DataFrame& _population_table );

    /// Extracts the schemas of the population table and the peripheral tables.
    void extract_schemas(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral );

    /// Spawns the threads for fitting new features.
    void fit_spawn_threads(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral,
        const helpers::RowIndexContainer& _row_indices,
        const helpers::WordIndexContainer& _word_indices,
        const std::optional<const helpers::FeatureContainer>&
            _feature_container,
        const std::shared_ptr<const logging::AbstractLogger> _logger );

    /// Fits a new candidate feature.
    void fit_candidate(
        const size_t _ix_table_used,
        const std::shared_ptr<lossfunctions::LossFunction>& _agg,
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function,
        const std::shared_ptr<const utils::StandardScaler>& _input_scaler,
        const std::shared_ptr<const utils::StandardScaler>& _output_scaler,
        const containers::DataFrameView& _output_table,
        const containers::DataFrame& _input_table,
        const containers::Subfeatures& _subfeatures,
        const containers::Rescaled& _output_rescaled,
        const containers::Rescaled& _input_rescaled,
        std::vector<containers::Match>* _matches,
        std::vector<
            std::tuple<decisiontrees::DecisionTree, Float, std::vector<Float>>>*
            _candidates ) const;

    /// Fits the scalers and applies them to the data.
    std::tuple<
        std::optional<containers::Rescaled>,
        std::optional<containers::Rescaled>,
        std::shared_ptr<const utils::StandardScaler>,
        std::shared_ptr<const utils::StandardScaler>>
    fit_transform_scalers(
        const containers::DataFrameView& _output,
        const containers::DataFrame& _input,
        const containers::Subfeatures& _subfeatures,
        const std::vector<containers::Match>::iterator _begin,
        const std::vector<containers::Match>::iterator _end ) const;

    /// After fitting a set of candidates, keep the best ones.
    void keep_best_candidates(
        const std::shared_ptr<lossfunctions::LossFunction>& _loss_function,
        const size_t _num_features,
        std::vector<
            std::tuple<decisiontrees::DecisionTree, Float, std::vector<Float>>>*
            _candidates );

    /// Prepares the aggregations for the candidate features to be fitted.
    std::vector<std::shared_ptr<lossfunctions::LossFunction>> make_aggregations(
        const std::shared_ptr<lossfunctions::LossFunction>& _child,
        const std::vector<containers::Match>& _matches,
        const containers::DataFrame& _input_table,
        const containers::DataFrameView& _output_table,
        const std::optional<containers::Rescaled>& _input_rescaled,
        const std::optional<containers::Rescaled>& _output_rescaled ) const;

    /// Returns the number of matches for each element of the population table.
    std::shared_ptr<std::vector<Float>> make_counts(
        const size_t _nrows,
        const std::vector<const containers::Match*>& _matches_ptr );

    /// Spawns the threads for the transform method.
    void transform_spawn_threads(
        const containers::DataFrame& _population,
        const std::vector<containers::DataFrame>& _peripheral,
        const std::vector<size_t>& _index,
        const std::optional<helpers::WordIndexContainer>& _word_indices,
        const std::optional<const helpers::FeatureContainer>&
            _feature_container,
        const std::shared_ptr<const logging::AbstractLogger> _logger,
        containers::Features* _features ) const;

    // -----------------------------------------------------------------

   private:
    /// Trivial (private) accessor
    multithreading::Communicator& comm() const
    {
        assert_true( impl().comm_ != nullptr );
        return *impl().comm_;
    }

    /// Whether the model has a population schema.
    const bool has_population_schema() const
    {
        return ( impl().population_schema_ && true );
    }

    /// Trivial (private) accessor
    DecisionTreeEnsembleImpl& impl() { return impl_; }

    /// Trivial (private) accessor
    const DecisionTreeEnsembleImpl& impl() const { return impl_; }

    /// Trivial (private) accessor
    Float& initial_prediction() { return impl().initial_prediction_; }

    /// Trivial (private) accessor
    const Float initial_prediction() const
    {
        return impl().initial_prediction_;
    }

    /// Trivial (private) accessor
    lossfunctions::LossFunction& loss_function()
    {
        assert_true( loss_function_ );
        return *loss_function_;
    }

    /// Trivial (private) accessor
    const lossfunctions::LossFunction& loss_function() const
    {
        assert_true( loss_function_ );
        return *loss_function_;
    }

    /// Trivial (private) setter.
    void set_comm( multithreading::Communicator* _comm )
    {
        impl().comm_ = _comm;
        loss_function().set_comm( _comm );
        for ( auto& tree : trees() ) tree.set_comm( _comm );
        for ( auto& subensemble : subensembles_avg_ )
            if ( subensemble ) subensemble->set_comm( _comm );
        for ( auto& subensemble : subensembles_sum_ )
            if ( subensemble ) subensemble->set_comm( _comm );
    }

    /// Trivial (private) accessor
    std::vector<Float>& targets()
    {
        assert_true( targets_ );
        return *targets_;
    }

    /// Trivial (private) accessor
    const std::vector<Float>& targets() const
    {
        assert_true( targets_ );
        return *targets_;
    }

    /// Trivial (private) accessor
    std::vector<decisiontrees::DecisionTree>& trees() { return impl().trees_; }

    /// Trivial (private) accessor
    const std::vector<decisiontrees::DecisionTree>& trees() const
    {
        return impl().trees_;
    }

    /// Updates the prediction.
    void update_predictions(
        const Float _update_rate,
        const std::vector<Float>& _predictions,
        std::vector<Float>* _yhat_old ) const
    {
        assert_true( _predictions.size() == _yhat_old->size() );
        std::transform(
            _yhat_old->begin(),
            _yhat_old->end(),
            _predictions.begin(),
            _yhat_old->begin(),
            [this, _update_rate]( const Float yhat, const Float pred ) {
                return yhat +
                       pred * hyperparameters().shrinkage_ * _update_rate;
            } );
    }

    // -----------------------------------------------------------------

   private:
    /// The implementation (variables we can copy without problems).
    DecisionTreeEnsembleImpl impl_;

    /// The loss function to be minimized.
    std::shared_ptr<lossfunctions::LossFunction> loss_function_;

    /// Contains the ensembles for the subfeatures trained with the intermediate
    /// aggregation AVG.
    std::vector<std::optional<DecisionTreeEnsemble>> subensembles_avg_;

    /// Contains the ensembles for the subfeatures trained with the intermediate
    /// aggregation SUM.
    std::vector<std::optional<DecisionTreeEnsemble>> subensembles_sum_;

    /// Target variables (previous trees already substracted).
    std::shared_ptr<std::vector<Float>> targets_;

    // -----------------------------------------------------------------
};

// ------------------------------------------------------------------------
}  // namespace ensemble
}  // namespace relmt

// ----------------------------------------------------------------------------

#endif  // RELMT_ENSEMBLE_DECISIONTREEENSEMBLE_HPP_
