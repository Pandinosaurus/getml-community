Example 6: Units (part 2)
--------------------------

For a full working example, please refer to :ref:`example_06_same_units_2.py` and :ref:`example_06_same_units_3.py`.

The idea of units also applies to discrete and categorical variables. Don't worry - AutoSQL would never compare categorical to numerical, categorical to discrete or discrete to numerical variables, even if you decide to assign them the same unit for some reason.

Suppose our problem is like this:

.. code-block:: sql

    SELECT t1.*,
    COALESCE( COUNT( * ), 0 ) AS target
    FROM POPULATION_TABLE t1
    LEFT JOIN PERIPHERAL_TABLE t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.column_01 = t2.column_01 )
    ) AND t2.time_stamps <= t1.time_stamps
    GROUP BY t2.join_key;

If we do not include the information that *column_01* in POPULATION_TABLE and PERIPHERAL_TABLE share the same unit, AutoSQL would have to create a special case for each possible manifestation of that variable. It is not impossible, but it is inefficient and the resulting SQL code would not be very beautiful.

High-level API
^^^^^^^^^^^^^^^^^^

The way units are assigned works exactly as for the previous example:

::

    units = dict()
    
    units["column_01"] = "unit_01"

And fitting is very similar as well, with the exception that we need to declare both *column_01* as categorical variables:

::

    population_placeholder = models.Placeholder(
        name="POPULATION",
        categorical=["column_01"],
        join_keys=["join_key"],
        time_stamps=["time_stamp"],
        targets=["targets"]
    )

    peripheral_placeholder = models.Placeholder(
        name="PERIPHERAL",
        categorical=["column_01"],    
        join_keys=["join_key"],
        time_stamps=["time_stamp"]
    )

    population_placeholder.join(peripheral_placeholder, "join_key", "time_stamp")

    model = models.Model(
        population=population_placeholder,
        peripheral=[peripheral_placeholder],
        units=units,  # Passing the units to the model
        loss_function=loss_functions.SquareLoss(),
        aggregation=[aggregations.Avg(),
                 aggregations.Sum(),
                 aggregations.Count()],
        use_timestamps=True,
        num_features=10,
        max_length=3,
        fast_training=True,
        min_num_samples=200,
        grid_factor=10.0,
        regularization=0.0,
        share_aggregations=1.0
    ).send()

    model = model.fit(
        population_table=population_table,
        peripheral_tables=[peripheral_table]
    )

Low-level API
^^^^^^^^^^^^^^^^^^

Here is how setting units works for the low-level API:

::

    # Set up units

    units = dict()

    units["column_01"] = "unit_01"

    # Upload data to the AutoSQL engine

    population_on_engine = engine.DataFrame(
        name="POPULATION",
        join_keys=["join_key"],
        categorical=["column_01"],
        time_stamps=["time_stamp"],
        targets=["targets"],
        units=units  # Passing units
    )

    population_on_engine.send(
        population_table
    )

    peripheral_on_engine = engine.DataFrame(
        name="PERIPHERAL",
        join_keys=["join_key"],
        categorical=["column_01"],
        time_stamps=["time_stamp"],
        units=units  # Passing units
    )

    peripheral_on_engine.send(
        peripheral_table
    )

Since you have already set the units in the data frame, you do not have to pass it to the model anymore:

::

    population_placeholder = models.Placeholder(name="POPULATION")

    peripheral_placeholder = models.Placeholder(name="PERIPHERAL")

    population_placeholder.join(peripheral_placeholder, "join_key", "time_stamp")

    model = models.Model(
        population=population_placeholder,
        peripheral=[peripheral_placeholder],
        loss_function=loss_functions.SquareLoss(),
        aggregation=[aggregations.Sum(),
                 aggregations.Count()],
        use_timestamps=True,
        num_features=10,
        max_length=3,
        fast_training=False,
        min_num_samples=200,
        grid_factor=10.0,
        share_aggregations=1.0
    ).send()

    model = model.fit(
        population_table=population_on_engine,
        peripheral_tables=[peripheral_on_engine]
    )

    features = model.transform(
        population_table=population_on_engine,
        peripheral_tables=[peripheral_on_engine]
    )

Validation
^^^^^^^^^^^^^^^^^^

Of course, the extracted features solve the problem perfectly:

.. image:: Example_6_ensemble.png

