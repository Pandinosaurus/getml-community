Example 2: Using the low-level API
-----------------------------------

For a full working example, please refer to :ref:`example_02_low_level.py`.

The high-level API is fine and reasonably easy, but there are disadvantages: Most importantly, it forces you to keep the data in the memory twice: Once as pandas.DataFrame() objects and once more as a copy in the engine. When your dataset is not too large or you have a lot of memory, then the high-level API is fine. But if memory is a real constraint, you want to think about using the low-level API (it really is not that much harder anyway).

For this example, we will create an artificial dataset that contains one POPULATION table and one PERIPHERAL table. The target variable is defined as follows:

.. code-block:: sql

    SELECT COUNT( * )
    FROM POPULATION t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.5 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.join_key,
         t1.time_stamp;

Building the model
^^^^^^^^^^^^^^^^^^

For the low-level API, we first want to upload the data to the engine. 

::


    # Upload data to the AutoSQL engine

    peripheral_on_engine = engine.DataFrame(
        name="PERIPHERAL",
        join_keys=["join_key"],
        numerical=["column_01"],
        time_stamps=["time_stamp"]
    )

    # The low-level API allows you to upload
    # data to the AutoSQL engine in a piecewise fashion.
    # Here we load the first part of the pandas.DataFrame...
    peripheral_on_engine.send(
        peripheral_table[:2000]
    )

    # ...and now we load the second part
    peripheral_on_engine.append(
        peripheral_table[2000:]
    )

    population_on_engine = engine.DataFrame(
        name="POPULATION",
        join_keys=["join_key"],
        numerical=["column_01"],
        time_stamps=["time_stamp"],
        targets=["targets"]
    )

    # The low-level API allows you to upload
    # data to the AutoSQL engine in a piecewise fashion.
    # Here we load the first part of the pandas.DataFrame...
    population_on_engine.send(
        population_table[:20]
    )

    # ...and now we load the second part
    population_on_engine.append(
       population_table[20:]
    )



Now the data is no longer in Python. Instead, it is kept in the AutoSQL engine. The objects created by this procedure are handles, which do not contain any actual data. As you can see, it also possible to load your data in a piecewise fashion. This is useful when your dataset is large and distributed over several CSV files.

Setting up your placeholder actually becomes easier.

::

    population_placeholder = models.Placeholder("POPULATION")

    peripheral_placeholder = models.Placeholder("PERIPHERAL")

    population_placeholder.join(peripheral_placeholder, "join_key", "time_stamp")

    model = models.Model(
        population=population_placeholder,
        peripheral=[peripheral_placeholder],
        predictor=linear_model.LinearRegression(),
        loss_function=loss_functions.SquareLoss(),
        aggregation=[aggregations.Sum(), aggregations.Count()],
        use_timestamps=True,
        num_features=10,
        max_length=1,
        fast_training=False,
        min_num_samples=200,
        shrinkage=0.0,
        grid_factor=1.0,
        share_aggregations=1.0
    ).send()

Everything else is pretty much the same. You just have to pass the *autosql.engine.DataFrame* object instead of a *pandas.DataFrame*. 

::

    model = model.fit(
        population_table=population_on_engine,
        peripheral_tables=[peripheral_on_engine]
    )

    features = model.transform(
        population_table=population_on_engine,
        peripheral_tables=[peripheral_on_engine]
    )

    yhat = model.predict(
        population_table=population_on_engine,
        peripheral_tables=[peripheral_on_engine]
    )

Generating SQL code
^^^^^^^^^^^^^^^^^^^^^

Once again, you can generate SQL code using the *.to_sql(...)* method:

::

    print(model.to_sql())

.. code-block:: sql

    CREATE TABLE FEATURE_1 AS
    SELECT COUNT( * ) AS feature_1,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.49607435974183928 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_2 AS
    SELECT COUNT( * ) AS feature_2,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.50005617269617941 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_3 AS
    SELECT COUNT( * ) AS feature_3,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.503629980961387 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_4 AS
    SELECT COUNT( * ) AS feature_4,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.50353410921761477 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_5 AS
    SELECT COUNT( * ) AS feature_5,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.49851269369130541 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_6 AS
    SELECT COUNT( * ) AS feature_6,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.50089469254785479 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_7 AS
    SELECT COUNT( * ) AS feature_7,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.503629980961387 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_8 AS
    SELECT COUNT( * ) AS feature_8,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.50110588950578139 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_9 AS
    SELECT COUNT( * ) AS feature_9,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.503629980961387 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;


    CREATE TABLE FEATURE_10 AS
    SELECT COUNT( * ) AS feature_10,
           t1.join_key,
           t1.time_stamp
    FROM (
         SELECT *,
            ROW_NUMBER() OVER ( ORDER BY join_key, time_stamp ASC ) AS rownum
         FROM POPULATION
    ) t1
    LEFT JOIN PERIPHERAL t2
    ON t1.join_key = t2.join_key
    WHERE (
       ( t1.time_stamp - t2.time_stamp <= 0.49851269369130541 )
    ) AND t2.time_stamp <= t1.time_stamp
    GROUP BY t1.rownum,
         t1.join_key,
         t1.time_stamp;

